# Урок 2. Создание классов и объектов
Напишите программу по следующему описанию. Есть класс "Воин". От него создаются два экземпляра
юнита. Каждому устанавливается здоровье в 100 очков. В случайном порядке они бьют друг друга. Тот, кто бьет, здоровья не теряет. У того, кого бьют, оно уменьшается на 20 очков от одного удара. После каждого 
удара надо выводить сообщение, какой юнит атаковал, и сколько у противника осталось здоровья. Как 
только у кого-то заканчивается ресурс здоровья, программа завершается сообщением о том, кто одержал 
победу.
# Урок 3. Конструктор класса.
Напишите программу по следующему описанию:
1.Есть класс Person, конструктор которого принимает три параметра (не учитывая self) – имя, 
фамилию и квалификацию специалиста. Квалификация имеет значение заданное по умолчанию, 
равное единице.
2.У класса Person есть метод, который возвращает строку, включающую в себя всю информацию о 
сотруднике.
3.Класс Person содержит деструктор, который выводит на экран фразу "До свидания, мистер …" 
(вместо троеточия должны выводиться имя и фамилия объекта).
4.В основной ветке программы создайте три объекта класса Person. Посмотрите информацию о 
сотрудниках и увольте самое слабое звено.
5.В конце программы добавьте функцию input(), чтобы скрипт не завершился сам, пока не будет нажат
Enter. Иначе вы сразу увидите как удаляются все объекты при завершении работы программы.
# Урок 4. Наследование
Разработайте программу по следующему описанию.
В некой игре-стратегии есть солдаты и герои. У всех есть свойство, содержащее уникальный номер 
объекта, и свойство, в котором хранится принадлежность команде. У солдат есть метод "иду за героем", 
который в качестве аргумента принимает объект типа "герой". У героев есть метод увеличения 
собственного уровня. 
В основной ветке программы создается по одному герою для каждой команды. В цикле генерируются 
объекты-солдаты. Их принадлежность команде определяется случайно. Солдаты разных команд 
добавляются в разные списки.
Измеряется длина списков солдат противоборствующих команд и выводится на экран. У героя, 
принадлежащего команде с более длинным списком, увеличивается уровень. 
Отправьте одного из солдат первого героя следовать за ним. Выведите на экран идентификационные 
номера этих двух юнитов.
# Урок 5. Полиморфизм
В качестве практической работы попробуйте самостоятельно перегрузить оператор сложения. Для его 
перегрузки используется метод  __add__(). Он вызывается, когда объекты класса, имеющего данный метод,
фигурируют в операции сложения, причем с левой стороны. Это значит, что в выражении a + b у объекта
a должен быть метод __add__(). Объект b может быть чем угодно, но чаще всего он бывает объектом того 
же класса. Объект b будет автоматически передаваться в метод __add__() в качестве второго аргумента 
(первый – self). 
Отметим, в Python также есть правосторонний метод перегрузки сложения – __radd__().
Согласно полиморфизму ООП, возвращать метод __add__() может что угодно. Может вообще ничего не 
возвращать, а "молча" вносить изменения в какие-то уже существующие объекты. Допустим, в вашей 
программе метод перегрузки сложения будет возвращать новый объект того же класса.
# Урок 6. Инкапсуляция
Разработайте класс с "полной инкапсуляцией", доступ к атрибутам которого и изменение данных 
реализуются через вызовы методов. В объектно-ориентированном программировании принято имена 
методов для извлечения данных начинать со слова get (взять), а имена методов, в которых свойствам 
присваиваются значения, – со слова set (установить). Например, get_field, set_field.
# Урок 7. Композиция
Приведенная в уроке программа имеет ряд недочетов и недоработок. Требуется исправить и доработать, 
согласно следующему плану.
При вычислении оклеиваемой поверхности мы не "портим" поле self.square. В нем так и остается полная 
площадь стен. Ведь она может понадобиться, если состав списка wd изменится, и придется заново 
вычислять оклеиваемую площадь. 
Однако в классе не предусмотрено сохранение длин сторон, хотя они тоже могут понадобиться. Например, 
если потребуется изменить одну из величин у уже существующего объекта. Площадь же помещения всегда
можно вычислить, если хранить исходные параметры. Поэтому сохранять саму площадь в поле не 
обязательно. 
Исправьте код так, чтобы у объектов Room были только четыре поля – width, lenght, height и wd. Площади 
(полная и оклеиваемая) должны вычислять лишь при необходимости путем вызова методов.
Программа вычисляет площадь под оклейку, но ничего не говорит о том, сколько потребуется рулонов 
обоев. Добавьте метод, который принимает в качестве аргументов длину и ширину одного рулона, а 
возвращает количество необходимых, исходя из оклеиваемой площади.
Разработайте интерфейс программы. Пусть она запрашивает у пользователя данные и выдает ему площадь 
оклеиваемой поверхности и количество необходимых рулонов.
# Урок 8. Перегрузка операторов
Напишите класс Snow по следующему описанию.
В конструкторе класса инициируется поле, содержащее количество снежинок, выраженное целым числом.
Класс включает методы перегрузки арифметических операторов: __add__() – сложение, __sub__() – 
вычитание, __mul__() – умножение, __truediv__() – деление. В классе код этих методов должен выполнять 
увеличение или уменьшение количества снежинок на число n или в n раз. Метод __truediv__() перегружает 
обычное (/), а не целочисленное (//) деление. Однако пусть в методе происходит округление значения до 
целого числа.
Класс включает метод makeSnow(), который принимает сам объект и число снежинок в ряду, а возвращает 
строку вида "*****\n*****\n*****…", где количество снежинок между '\n' равно переданному аргументу, а
количество рядов вычисляется, исходя из общего количества снежинок.
Вызов объекта класса Snow в нотации функции с одним аргументом, должен приводить к перезаписи 
значения поля, в котором хранится количество снежинок, на переданное в качестве аргумента значение.
# Урок 9. Модули и пакеты
В практической работе урока 7 "Композиция" требовалось разработать интерфейс взаимодействия с 
пользователем. Разнесите сам класс и интерфейс по разным файлам. Какой из них выполняет роль модуля, 
а какой – скрипта? Оба файла можно поместить в один каталог.
# Урок 10. Документирование кода
Выполните полное документирование модуля, созданного в практической работе прошлого урока.
# Урок 11. Пример объектно-ориентированной программы на Python
Может ли в этой программе ученик учиться без учителя? Если да, пусть научится чему-нибудь сам.
Добавьте в класс Pupil метод, позволяющий ученику случайно "забывать" какую-нибудь часть своих 
знаний